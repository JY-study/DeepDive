# 11-2. 함수 (2)

## 내부 / 외부 함수

```jsx
function outer() {
  // outer는 외부함수
  function inner() {
    // inner는 내부함수
  }
}
```

함수 내부에 정의된 함수를 중첩 함수 or 내부 함수라 하며,<br>
중첩 함수를 포함하는 함수는 외부 함수라 한다.<br>
중첩 함수는 외부 함수 내부에서만 호출할 수 있으며 보통 외부 함수를 돕는 헬퍼 함수의 역할을 한다.

## 반환문의 역할

1. 함수 실행 중 `return`을 만나면 실행을 중단하고 함수 몸체를 빠져나간다.<br>
   → 반환문 이후에 존재하는 문은 `실행되지 않고 무시`된다.

   ```jsx
   function multiply(x,y) {
   	return
   	x+*y; // 무시됨
   }
   console.log(multiply(3,5)); // undefined
   ```

2. `return` 뒤에 오는 표현식을 평가해 반환하는데, 만약 **표현식을 명시적으로 지정하지 않으면** `undefined가 반환`된다.

   ```jsx
   function foo() {
     return;
   }
   console.log(foo()); // undefiend

   function bar() {
     // 반환문 생략
   }
   console.log(bar()); // undefined
   ```

## 매개변수로의 전달

<img src='https://user-images.githubusercontent.com/85178602/225815170-fa2b3cab-4d69-45bc-b4e1-7536d3655138.png' width='600px' />

### 원시 타입의 인수

원시 타입 인수는 **값 자체가 복사**되어 매개변수에 전달되기 때문에 함수 몸체에서 값을 변경해도 **원본이 훼손되지 않는다.**<br>
→ 함수 외부에서 내부로 전달한 원시 값의 원본을 변경하는 `부수효과는 발생하지 않는다.`

### 객체 타입의 인수

객체 타입 인수는 **참조 값이 복사**되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경하면 **원본이 훼손된다.**<br>
→ 함수 외부에서 내부로 전달한 참조 값에 의해 원본 객체가 변경되는 `부수 효과가 발생한다.`

함수가 외부 상태를 변경할 수 있게 되면 **상태 변화를 추적하기 어려워져** 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. <br>
이러한 문제를 해결하기 위해선 객체를 `불변 객체`로 만들어 사용하는 것이다.

객체의 복사본을 새로 생성하는 비용은 들지만 원본 객체를 완전히 복제하는 `깊은 복사`를 통해<br>
`새로운 객체를 생성`하고 `재할당을 통해 값을 변경`하면 부수효과를 없앨 수 있다.

## 재귀 함수

**재귀 호출**: 함수가 자기 자신을 호출하는 것<br>
**재귀 함수**: 재귀 호출을 수행하는 함수

재귀 함수는 `반복되는 처리`를 위해 사용한다.<br>
재귀 함수는 자신을 무한 재귀 호출하기 때문에 재귀 함수 내에는 `재귀 호출을 멈출 수 있는 탈출 조건`을 반드시 만들어야 한다.

재귀 함수는 **무한 반복에 빠질 위험**이 있기 때문에<br>
반복문을 사용하는 것보다 재귀 함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만<br>
**한정적으로 사용하는 것**을 권장!

## 콜백 함수

**콜백 함수**: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수<br>
이 때 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 `고차 함수(HOF)`라 한다.

```jsx
// n만큼 어떤 일을 반복
function repeat1(n) {
  // i를 출력
  for (var i = 0; i < n; i++) console.log(i);
}

// n만큼 어떤 일을 반복
function repeat2(n) {
  for (var i = 0; i < n; i++) {
    // i가 홀수일 때만 i를 출력
    if (i % 2) console.log(i);
  }
}
```

위 함수는 n만큼 어떤 일을 반복한다는 것은 동일하지만 하는 일의 내용은 다르다.<br>
→ 함수의 일부분만 다르다는 이유로 _매번 함수를 새롭게 정의_ 해야 한다.

이는 함수의 **공통 로직은 미리 정의**해두고, 경우에 따라 **변경되는 로직은 추상화**하여<br>
함수 외부에서 내부로 전달하여 해결할 수 있다.

```jsx
// 외부에서 전달받은 f를 n만큼 반복
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

const logAll = (i) => console.log(i);

const logOdds = (i) => {
  if (i % 2) console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4
repeat(5, logOdds); // 1 3
```

`repeat`함수는 더 이상 내부 로직에 강하게 의존하지 않고<br>
외부에서 로직의 일부분을 함수로 전달받아 수행하므로 더욱 유연한 구조를 갖게 된다.<br>
→ 콜백 함수를 사용

고차 함수는 매개변수를 통해 전달받은 `콜백 함수의 호출 시점을 결정해서 호출`한다.<br>
→ 대부분의 콜백 함수는 **고차 함수에 의해 호출**되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

```jsx
// 익명 함수를 콜백 함수로 전달
// repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성함
repeat(5, (i) => console.log(i));

// logAll 함수는 단 한 번만 생성됨
const logAll = (i) => console.log(i);
// 함수 참조를 콜백 함수로 전달
repeat(5, logAll);
```

위 코드를 보면, 고차 함수에 콜백 함수로 익명 함수를 전달할 경우<br>
고차 함수가 호출될 때마다 평가되어 콜백 함수를 생성한다.

콜백 함수를 다른 곳에서도 사용하거나, 자주 호출된다면<br>
따로 **콜백 함수를 정의한 후에 함수 참조를 고차 함수에 전달**하는 것이 낫다.

(map, filter, forEach 등을 고차함수라고 부르는 이유는, 콜백 함수를 받아서 실행하는 함수이기 때문이었다!)

## 순수 함수

순수 함수는 `동일한 인수가 전달`되면 언제나 `동일한 값을 반환`<br>
→ 어떤 외부 상태에도 **의존하지 않고** 외부 상태를 **변경하지도 않으며**,<br>
오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성 후 반환

하지만 함수 내부 상태에만 의존한다 해도 그 내부 상태가 호출될 때마다 변하는 값이라면 순수 함수가 아님<br>
(ex. 현재 시간 출력)

순수 함수는 일반적으로 **최소 하나 이상의 인수를 전달받는다.**<br>
(인수를 전달받지 않는 순수 함수는 언제나 동일한 값을 반환하므로 결국 상수와 마찬가지)

```jsx
let count = 0;

// 순수 함수
function increase(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2

// 비순수 함수
function increase() {
  // 외부 상태에 의존하며 외부 상태를 변경
  return ++count;
}

// 외부 상태인 count를 변경하므로 상태 변화를 추적하기 어려워짐
increase();
console.log(count); // 1

increase();
console.log(count); // 2
```

위 코드의 비순수 함수 부분을 보면, 인수를 전달받지 않고 함수 내부에서 외부 상태를 직접 참조할 경우<br>
외부 상태에 의존하게 되어 반환값이 변할 수 있고, <br>
외부 상태도 변할 수 있어서 상태 변화를 추적하기 어려워진다.

## 함수형 프로그래밍

순수 함수와 보조 함수의 조합을 통해 `외부 상태를 변경하는 부수 효과를 최소화`해서 **불변성을 지향**하는 프로그래밍 패러다임

로직 내 존재하는 **로직의 흐름을 이해하기 어렵게 해 가독성을 해치는** 조건문과 반복문을 제거하여 `복잡성을 낮추고`,<br>
**누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적인 원인이 될 수 있는** 변수 사용을 억제하거나 생명주기를 최소화하여<br>
`상태 변경을 피해 오류를 최소화` 하는 것을 목표로 한다.
