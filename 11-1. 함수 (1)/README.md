# 11-1. 함수 (1)

## 함수란?

프로그래밍 언어의 **함수**는 일련의 과정을 문으로 구현하고 **코드 블록**으로 감싸서 **하나의 실행 단위로 정의**한 것이다.<br>
함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고, 값을 반환한다.<br>
함수는 여러 개 존재할 수 있는 값이므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.

<img src='https://user-images.githubusercontent.com/85178602/225517154-0c045f7d-1735-4cc0-8db3-70714b5ba6cf.png' width='350px' />

함수는 실행 시점을 개발자가 결정할 수 있고, 몇 번이든 필요할 때 여러 번 호출할 수 있어서 **재사용이 가능**하다.<br>
→ **코드의 재사용**

_함수를 사용하지 않고 같은 코드를 중복해서 여러 번 작성_ 하면 코드를 수정해야 할 때 _중복된 횟수만큼 코드를 수정_ 해야 한다.<br>
즉, **코드의 중복을 줄이고 재사용성을 높이는 함수**는 _유지보수의 편의성_ 을 높이고 실수를 줄여 **코드의 신뢰성을 높이는 효과**가 있다.

### 함수의 정의

<img src='https://user-images.githubusercontent.com/85178602/225517260-0e7b15e3-2c3c-4587-a3f0-a1837cf0d100.png' width='700px' />

함수 선언문은 _별도의 변수 선언 없이_ 함수를 정의하고 있다.<br>
JS 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.<br>
즉, 함수는 함수 이름으로 호출하는 것이 아니라 **함수 객체를 가리키는 식별자로 호출**한다.

<img src='https://user-images.githubusercontent.com/85178602/225517391-18df8112-5d9d-43d9-8559-24f945346941.png' width='400px' />

`{}`은 블록문일 수도 있고 객체 리터럴일 수도 있다<br>
→ 블록문: `{}`이 단독으로 존재할 시 블록문으로 해석<br>
→ 객체 리터럴: `{}`이 값으로 평가되어야 할 문맥일 땐 객체 리터럴로 해석

기명 함수 리터럴은 위와 같이 중의적인 코드로, 코드의 문맥에 따라 해석이 달라지게 된다.<br>
→ 함수 선언문 or 함수 표현식<br>
→ 함수 선언문: 표현식이 아닌 문<br>
→ 함수 표현식: 표현식인 문

### 일급객체

함수는 일급객체이다.<br>
**일급 객체**: 값의 성질을 갖는 객체<br>
(함수는 값처럼 변수에 할당, 프로퍼티의 value, 배열의 요소가 될 수 있다.)<br>
이러한 성질을 이용하여 함수를 정의한 것이 함수 표현식이다.

## 호이스팅

호이스팅이란 선언부가 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.

```js
// 함수 참조
console.dir(add); // f add(x,y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```

위 코드를 보면 add함수는 선언문 이전에 참조되고 호출되지만,<br>
sub함수는 선언문 이전에 참조하지 못하며 호출 시 에러가 발생한다.

함수 선언문으로 정의한 함수는 호이스팅에 의해 함수 선언문 이전에 호출할 수 있다.<br>

### 함수 호이스팅과 변수 호이스팅의 차이

var 키워드를 사용한 변수 선언문과 함수 선언문은<br>
_런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성_ 한다는 점에서는 동일하다.<br>
하지만 **var 키워드로 선언된 변수는 undefined로 초기화**되고 **함수 선언문은 함수 객체로 초기화**된다.<br>
함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생한다.

화살표 함수로 함수를 정의하면 arguments 객체를 생성하지 않는다.
(이 부분 관련해서 다시 찾아보기)

## 함수의 호출

함수를 호출하면 _현재의 실행 흐름을 중단_ 하고 **호출된 함수로 실행 흐름을 옮긴다.**<br>
함수는 매개변수(인자)를 통해 값으로 평가될 수 있는 표현식인 인수를 전달한다.<br>

함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고,<br>
일반 변수와 마찬가지로 **undefined로 초기화된 이후 인수가 순서대로 할당**된다.<br>

**매개변수**는 함수 몸체 내부에서만 참조할 수 있고 **외부에서는 참조할 수 없다**<br>
_→ 매개변수의 스코프(유효 범위)는 함수 내부이다_

```js
function add(x, y) {
  // x와 y는 처음 함수가 실행될 때 undefined로 초기화된다
  // x에는 인수로 전달된 2가 재할당 되고 y는 그대로 undefined이다
  return x + y;
}

// 따라서 2 + undefined가 계산되어 NaN이 반환된다
console.log(add(2)); // NaN
```

위처럼 함수를 호출할 때 매개변수의 개수보다 적은 인수를 전달해도 오류가 발생하지 않는다.<br>
만약 매개변수의 개수를 초과하여 인수를 전달한다면 초과된 인수는 무시된다.

함수를 사용할 때 매개변수의 개수나 순서가 변경되면 함수의 호출 방법, 반환 값이 달라지므로<br>
함수를 사용하는 코드 전체가 영향을 받게된다.<br>
→ 유지보수가 나쁘다

_매개변수가 많다는 것_ 은 _함수가 여러가지 일을 한다_ 는 증거이므로 바람직하지 않다.<br>
**이상적인 함수는 한 가지 일**만 해야 하며 **가급적 작게** 만들어야 한다.<br>
그래서 이상적인 매개변수 개수는 0개이며 적을수록 좋다.

만약 여러개의 매개변수를 전달해야할 땐 객체를 인수로 전달하는 것이 유리하다.<br>
하지만 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면<br>
**외부 객체가 변경되는 side effect(부수 효과)**가 발생하기 때문에 주의해야 한다.
