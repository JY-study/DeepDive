# 10. 원시 값과 객체의 비교

## 총 정리 table

| <strong>원시값</strong>                                                | ↔   | <strong>객체값</strong>                                                  |
| :--------------------------------------------------------------------- | :-- | :----------------------------------------------------------------------- |
| 변경 불가능한 값 (읽기 전용 값)                                        | ↔   | 변경 가능한 값                                                           |
| 변수에 할당하면 변수에 실제 값이 저장됨                                | ↔   | 변수에 할당하면 변수에 참조 값이 저장됨                                  |
| 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달됨 (값에 의한 전달) | ↔   | 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨 (참조에 의한 전달) |

## 원시값

원시값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라,<br>
**새로운 메모리 공간을 확보**하고 재할당한 원시 값을 저장한 후,<br>
변수는 새롭게 재할당한 원시 값을 가리키면서 **변수가 참조하던 메모리 공간의 주소가 바뀐다**<br>
→ **불변성(immutability)**

```js
var score = 80;
var copy = score;
```

이 때 copy에는 새로운 숫자 값 80이 생성되어 copy 변수에 할당되는 것이다.<br>
(score에 할당되어있는 80과는 상관 없음)<br>
→ **원본의 원시 값이 복사**되어 전달되는 것<br>
→ score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.

## 객체

**참조 값**은 생성된 객체가 저장된 **메모리 공간의 주소**이다.<br>
객체를 할당한 변수는 **재할당 없이 객체를 직접 변경할 수 있기 때문에** 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제할 수 있다.<br>
즉, 메모리에 저장된 객체를 직접 수정할 수 있으며 **객체를 할당한 변수의 참조값**은 재할당 한 것이 아니므로 **변경되지 않는다.**

객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일이어서<br>
원시값처럼 이전 값을 복사해서 새롭게 생성한다면<br>
객체는 크기가 일정하지 않으며, 프로퍼티 값도 객체일 수 있어서 비용이 많이 들게된다.<br>
→ 메모리의 효율적인 소비가 어렵고 성능이 나빠진다.

메모리를 효율적으로 사용하기 위해서,<br>
객체를 복사해서 생성하는 비용을 절약해 성능을 향상시키기 위해서<br>
객체는 변경 가능한 값으로 설계 되어있다.<br>
하지만 **여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것**이 **단점**이다.

```js
var person = {
	name = 'Lee'
};

var copy = person; // 얕은 복사
```

얕은 복사의 경우 원본 person과 사본 copy는 저장된 메모리 주소는 다르지만,<br>
**동일한 참조 값**을 갖는다.<br>
→ 원본 person과 사본 copy는 동일한 객체를 가리킨다.<br>
→ **두 개의 식별자가 하나의 객체를 공유**한다.

이런 경우에 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받기 때문에 조심해야 한다.
